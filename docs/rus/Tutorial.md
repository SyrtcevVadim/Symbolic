# Знакомство
___
* [Установка фреймворка](#GettingStarted)
* [Математические выражения](#SymExpression)
* [Константы](#Constants)
* [Параметры](#Parameters)
* [Проверка ошибок](#Correctness)
* [Следующие шаги](#NextStep)

## <a name="GettingStarted"></a> Установка фреймворка
___
Самый простой и единственный(пока что) путь установки фреймворка *Symbolic* - скачать весь репозиторий проекта,
скопировать папку *src* в свою папку проекта и переименовать ее в *symbolic*. В дальнейшем, для включения заголовочных файлов фреймворка пишите вот так:
`#include"symbolic/...h"`

В следующих примерах я буду использовать именно этот подход.

## <a name ="SymExpression"></a> Математические выражения
___
Давайте начнем с простого. Представьте, что у вас есть функция *y=x+1*, и вы хотите вычислить ее значение в точке *x=5*.

Чтобы сделать это в *Symbolic*, следуйте трём шагам(поместите весь код в *main.cpp*):

1. Включите следующие заголовочные файлы.
```c++
#include<iostream>                 // Для вывода результата
#include"symbolic/SymExpression.h"
#include"symbolic/SymCalculator.h"
```

> *SymExpression.h* нужен для работы с математическими выражениями. В нем объявляется класс *SymExpression* для работы с телами функций или с арифметическими выражениями.

> *SymCalculator.h* нужен для вычисления значений математических выражений. В нем объявляется класс *SymCalculator*, который вычисляет значения выражений.

2. Определите переменную для хранения математического выражения.

```c++
SymExpression expression("x+1");
```

3. Посчитайте значение f(5) с помощью объекта класса *SymCalculator*

```
SymCalculator calculator(expression);
std::cout << calculator.compute(5.0) << '\n';
```

В консоль будет выведено число *6*. Обязательно попробуйте повторить пример!

## <a name ="Constants"></a> Константы
___
Когда вы работаете с множеством математических выражений, бывает утомительно постоянно печатать их "с нуля". *Symbolic* предоставляет *механизм создания констант*. Как же это работает?

В фреймворке *Symbolic*, константы - предопределённые пользователем выражения, у которых есть уникальное имя. Для работы с *константами* включите *SymConstantManager.h* в ваши файлы.

Давайте рассмотрим пример. Представьте,что у вас есть *очень* большое математическое выражение, например, `1777*x^7-833*x^3+tg(log(5,25)*x-4)`, и вы хотите использовать это выражение в качестве составной части другого выражения(например, вы захотите сложить это выражение с каким-нибудь еще более монструозным выражением). В *Symbolic* вам следует определить *константу*:
```
#include"symbolic/SymConstantManager.h"
#include"symbolic/SymExpression.h"
...
string strExp{"1777*x^7-833*x^3+tg(log(5,25)*x-4)"};
SymConstantManager::AddConstant("z",strExp);        // z - имя константы
...
SymExpression expression("z+1");
```
А теперь по порядку. Во-первых, мы определили *константу* с помощью метода `AddConstant()` класса *SymConstantManager*. Его аргументами являются имя константы и ее значение.

> Учтите, что в качестве имени константы не стоит выбирать одно из *зарезервированных* имён, например `x` или `sin`. Об этом вы можете прочитать в [Справке](Reference.md).

Во-вторых, мы использовали имя константы в качестве составной части другого выражения. На самом деле, *expression* содержит `1777*x^7-833*x^3+tg(log(5,25)*x-4)+1`(обратите внимание на последние два символа!). В результате, *механизм констант* может сохранить вам время и дать отличные возможности пользователям вашей программы.

Кроме того, если вы подключите файл *SymConstantManager.h*, вы сможете использовать несколько предопределённых *математических констант* в ваших выражениях: `pi`(3.141592..) and `e`(2.718281828)

```
SymExpression expression("cos(2*pi)-4*e");
```

## <a name = "Parameters"></a> Параметры
___
Когда вы учились в школе, вы, почти наверняка, знакомились с параметрами в *математических выражениях*.
Вкратце, параметр - буква, которая может принимать любое действительное число. Рассмотрим пример:
```
#include"symbolic/SymExpression.h"
#include"symbolic/SymCalculator.h"
...
SymExpression expression("a*x+b");
```
У нас есть выражение с двумя параметрами: *a* и *b*. По умолчанию, значение параметров равно единице. Таким образом, вы можете вычислить значение этого выражения:
```
SymCalculator calculator(expression);
// By default the argument of compute method is equal to 0.0
std::cout << calculator.compute() <<'\n';
```
В результате, в консоль будет выведено: *1*.
> Фреймворк *Symbolic* поддерживает 4 параметра для использования в математических выражениях: *a*, *b*, *c* and *d*.

Кроме того, вы можете придать любому параметру произвольное действительное значение(которое помещается в переменную типа *int*):
```
expression.setParameterValue("a", 3.0);
expression.setParameterValue("b", 7.0);
// You can also replace it by expression.setParameterValues(3.0, 7.0). It's exactly the same thing
std::cout << calculator.compute(1.0) << '\n';
```
Результат будет равен *10*.

## <a name= "Correctness"></a> Проверка ошибок
___
Пользователи всегда делают много ошибок, которые могут привести вашу программу к сбою. Я полагаю, вы хотите, чтобы ваши программы были стабильны к любым видам ошибок.

Для проверки корректности математических выражений *Symbolic* предоставляет специальный класс *SymVerifier*, который объвляется в файле `SymVerifier.h`. Объекты этого класса могут проверять корректность ввода математических выражений пользователем.
```c++
#include"symbolic/SymVerifier.h"
...
string userExpression;                  // Пользовательское математическое выражение
```
Представьте, что вы хотите проверить, все ли элементы математического выражения корректны:
```c++
SymVerifier verifier(userExpression);  // Связывает математическое выражение с проверщиком
if(verifier.areAllTokensCorrect())
{
  std::cout << "All tokens are correct inside \"" << userExpression << "\"!\n";
}
```

Если вкратце, метод `areAllTokensCorrect()` проверяет, есть ли в математическом выражении элементы, которые не имеют математического смысла. Например, этот метод может вам сказать, что выражения `abra+cadabra-7` и `bla/bla+1` некорректны.

Класс *SymVerifier* определяет множество методов для проверки. Вы можете прочитать о каждом из них в [Справке](Reference.md). Тем не менее, если вам просто надо знать, есть ли в математическом выражении ошибки, используйте метод `isCorrect()`. Если выражение истинно, он возвращает *true*, иначе - *false*. Кроме того, если выражение некорректно, вы можете получить сообщение об ошибке:
```c++
string expression{"x-blabla"};
SymVerifier verifier(expression);
if(!verifier.isCorrect())
{
// Будет выведено сообщение: Unknown token "blabla" was received
  std::cout << verifier.getErrorMessage(); 
}
```
Возможно, вам захочется выводить ваше собственное сообщение об ошибки. В таком случае, вы можете узнать *тип ошибки*(*error-code*) после выполнения любого метода проверки.

> *Типы ошибки*(*error-codes*) - это объекты перечисления *SymError*, который определен в файле *SymVerifier.h*

Определено 6 *типов ошибок*:
1. NO_ERROR (выражение корректно)
2. INCORRECT_TOKEN (выражение соддержит недопустимый элемент)
3. INCORRECT_BRACKETS (Типы открывающих и закрывающих скобок не совпадают: `(]`,`(`, `{}}` 
4. EMPTY_BRACKETS (Скобки пусты: `()`, `[]`, `{}`)
5. MISSED_OPERATION (Пропущена операция: `1 1`)
6. MISSED_OPERANDS (Недостаточно аргументов: `pow(2,)`, `1+`)

Пример использования:
```c++
...// Выполение методов-проверки
switch(verifier.getErrorType())
{
  case SymError::NO_ERROR:
    std::cout << "Everything is fine!\n";
    break;
  case SymError::EMPTY_BRACKETS:
    std::cout << "You have missed an expression between "+verifier.getIncorrectPlace() <<'\n';
    break;
  ...
}
```
> `getIncorrectPlace()` возвращает несколько элементов, которые находятся вблизи места ошибки. Результат зависит от *типа ошибки*. Например, если в выражении содержится недопустимый элемент, метод вернет этот токен(например: `abra+5`->`abra`). Если выражение содержит пустые скобки, метод ведёт эту пару скобок(например: `()+1`->`()`). Об этом вы можете подробнее прочитать в [справке](Reference.md).

## <a name = "NextStep"></a> Следующие шаги
___
Это было краткое знакомство с фреймворком *Symbolic*. Этого достаточно, чтобы начать работать с основной функциональностью и чтобы продолжить изучение фреймворка.

Разумеется, есть еще много интересных возможностей, которые я не осветил в этом введении. Пожалуйста, за всеми деталями обращайтесь к [справке](Reference.md).

