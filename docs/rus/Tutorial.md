# Знакомство
___
* [Установка фреймворка](#GettingStarted)
* [Математические выражения](#SymExpression)
* [Константы](#Constants)
* [Параметры](#Parameters)
* [Проверка ошибок](#Correctness)
* [Следующие шаги](#NextStep)

## <a name="GettingStarted"></a> Установка фреймворка
___
Самый простой и единственный способ установки фреймворка *Symbolic* - скачать весь репозиторий,
скопировать папку *src* в свой проект и переименовать ее в *symbolic*. В дальнейшем, для включения заголовочных файлов пишите:
`#include"symbolic/...h"`

В своих примерах я буду использовать именно этот подход.

## <a name ="SymExpression"></a> Математические выражения
___
Начнем с простого. Представьте, что у вас есть функция *y=x+1*, и вы хотите вычислить ее значение в точке *x=5*.

Чтобы сделать это в *Symbolic*, следуйте трём шагам(поместите весь код в *main.cpp*):

1. Подключите следующие заголовочные файлы.
```c++
#include<iostream>                 
#include"symbolic/SymExpression.h"
#include"symbolic/SymCalculator.h"
```

> *SymExpression.h* нужен для работы с математическими выражениями. В нем объявляется класс *SymExpression* для работы с пользовательскими выражениями.

> *SymCalculator.h* нужен для вычисления значений математических выражений. В нем объявляется класс *SymCalculator*,объекты которого вычисляют значения выражений.

2. Определите переменную для хранения математического выражения.

```c++
SymExpression expression("x+1");
```

3. Посчитайте значение f(5) с помощью объекта класса *SymCalculator*

```
SymCalculator calculator(expression);
std::cout << calculator.compute(5.0) << '\n';
```

В консоль будет выведено число *6*. Обязательно попробуйте повторить этот пример!

## <a name ="Constants"></a> Константы
___
Когда вы работаете с множеством математических выражений, бывает утомительно постоянно печатать их "с нуля". *Symbolic* предоставляет *механизм создания констант*. Как же он работает?

В фреймворке *Symbolic*, константы - предопределённые пользователем выражения, у которых есть уникальное имя. Для работы с *константами* подключите заголовочный файл *SymConstantManager.h*.

Рассмотрим пример. Представьте,что у вас есть *очень* большое математическое выражение, например, `1777*x^7-833*x^3+tg(log(5,25)*x-4)`, и вы хотите использовать это выражение в качестве составной части другого выражения(например, вы захотите сложить это выражение с каким-нибудь еще более монструозным выражением). В *Symbolic* вы можете поступить так:
```
#include"symbolic/SymConstantManager.h"
#include"symbolic/SymExpression.h"
...
string strExp{"1777*x^7-833*x^3+tg(log(5,25)*x-4)"};
SymConstantManager::AddConstant("z",strExp);        // z - имя константы
...
SymExpression expression("z+1");
```
А теперь по порядку. Во-первых, мы определили *константу* с помощью метода `AddConstant()` класса *SymConstantManager*. Его аргументами являются *имя константы* и ее *значение*.

> Учтите, что в качестве имени константы нельзя исользовать *зарезервированные* имена, например `x` или `sin`. Подробнее об этом вы можете прочитать в [Справке](Reference.md).

Во-вторых, мы использовали константу в качестве составной части другого выражения. На самом деле, *expression* содержит `1777*x^7-833*x^3+tg(log(5,25)*x-4)+1`(обратите внимание на последние два символа!). В результате, *механизм констант* поможет сохранить вам время и дать отличные возможности пользователям вашей программы.

Кроме того, если вы подключите файл *SymConstantManager.h*, вы сможете использовать несколько предопределённых *математических констант* в ваших выражениях: `pi`(3.141592..) and `e`(2.718281828):

```
SymExpression expression("cos(2*pi)-4*e");
```

## <a name = "Parameters"></a> Параметры
___
Когда вы учились в школе, вы, почти наверняка, знакомились с параметрами внутри различных функций.
Вкратце, параметр - буква, которая может принимать любое действительное число. Рассмотрим пример:
```
#include"symbolic/SymExpression.h"
#include"symbolic/SymCalculator.h"
...
SymExpression expression("a*x+b");
```
У нас есть выражение с двумя параметрами: *a* и *b*. По умолчанию, значения параметров равно единице. Таким образом, вы можете вычислить значение этого выражения:
```
SymCalculator calculator(expression);
// По умолчанию, аргумент метода compute равен 0.0
std::cout << calculator.compute() <<'\n';
```
В результате, в консоль будет выведена *1*.
> Фреймворк *Symbolic* поддерживает 4 параметра для использования в математических выражениях: *a*, *b*, *c* and *d*.

Кроме того, вы можете придать любому параметру произвольное действительное значение, которое помещается в переменную типа *int*:
```
expression.setParameterValue("a", 3.0);
expression.setParameterValue("b", 7.0);
// Вы можете заменить эти вызовы setParameterValues(3.0, 7.0)
std::cout << calculator.compute(1.0) << '\n';
```
Результат будет равен *10*.

## <a name= "Correctness"></a> Проверка ошибок
___
Пользователи всегда делают много ошибок, которые могут привести вашу программу к краху. Я полагаю, вы хотите, чтобы ваши программы были стабильны к любым видам ошибок.

Для проверки корректности математических выражений *Symbolic* предоставляет специальный класс *SymVerifier*, который объявлен в файле `SymVerifier.h`:
```c++
#include"symbolic/SymVerifier.h"
...
string userExpression{x+1};                  // Пользовательское математическое выражение
```
Представьте, что вы хотите проверить, все ли элементы математического выражения корректны:
```c++
SymVerifier verifier(userExpression);  // Связывает математическое выражение с проверщиком
if(verifier.areAllTokensCorrect())
{
  std::cout << "All tokens are correct inside \"" << userExpression << "\"!\n";
}
```

Если вкратце, метод `areAllTokensCorrect()` проверяет, есть ли в математическом выражении элементы, которые не имеют математического смысла. Например, этот метод может вам сказать, что выражения `abra+cadabra-7` и `bla/bla+1` некорректны.

Класс *SymVerifier* определяет множество методов для проверки. Вы можете прочитать о каждом из них в [Справке](Reference.md). Тем не менее, если вам просто надо знать, есть ли в математическом выражении ошибки, используйте метод `isCorrect()`. Если выражение записано правильно, он возвращает *true*, иначе - *false*. Кроме того, если выражение некорректно, вы можете получить стандартное сообщение об ошибке:
```c++
string expression{"x-blabla"};
SymVerifier verifier(expression);
if(!verifier.isCorrect())
{
// Будет выведено сообщение: Unknown token "blabla" was received
  std::cout << verifier.getErrorMessage(); 
}
```
Возможно, вам захочется выводить ваше собственное сообщение об ошибке. В таком случае, вы можете узнать *тип ошибки*(*error-code*) после выполнения любого метода проверки.

> *Типы ошибки*(*error-codes*) - это объекты перечисления *SymError*, который определен в файле *SymVerifier.h*

Существует 6 *типов ошибок*:
1. NO_ERROR (выражение корректно)
2. INCORRECT_TOKEN (выражение соддержит недопустимый элемент)
3. INCORRECT_BRACKETS (Типы открывающих и закрывающих скобок не совпадают: `(]`,`(`, `{}}` 
4. EMPTY_BRACKETS (Пустые скобки: `()`, `[]`, `{}`)
5. MISSED_OPERATION (Пропущена операция: `1 1`)
6. MISSED_OPERANDS (Недостаточно аргументов: `pow(2,)`, `1+`)

Пример использования:
```c++
...// Выполение методов-проверки
switch(verifier.getErrorType())
{
  case SymError::NO_ERROR:
    std::cout << "Everything is fine!\n";
    break;
  case SymError::EMPTY_BRACKETS:
    std::cout << "You have missed an expression between "+verifier.getIncorrectPlace() <<'\n';
    break;
  ...
}
```
> `getIncorrectPlace()` возвращает несколько элементов, которые находятся вблизи места ошибки. Результат зависит от *типа ошибки*. Например, если в выражении содержится недопустимый элемент, метод вернет этот токен(например: `abra+5`->`abra`). Если выражение содержит пустые скобки, метод ведёт эту пару скобок(например: `()+1`->`()`). Об этом вы можете подробнее прочитать в [справке](Reference.md).

## <a name = "NextStep"></a> Следующие шаги
___
Это было краткое знакомство с фреймворком *Symbolic*. Этого достаточно, чтобы начать работать с основной функциональностью и чтобы продолжить изучение.

Разумеется, есть еще много интересных возможностей, которые я не осветил в этом введении. Пожалуйста, за всеми деталями обращайтесь к [справке](Reference.md).

